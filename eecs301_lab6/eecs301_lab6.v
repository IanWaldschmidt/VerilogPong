//Justin Lee (jpl88) and Ian Waldschmidt (isw5)
// The top-level Verilog file for eecs301_lab6
// This code was initially generated by Terasic System Builder

module eecs301_lab6(

         //////////// ADC //////////
         output ADC_CONVST,
         output ADC_DIN,
         input ADC_DOUT,
         output ADC_SCLK,

         //////////// CLOCK //////////
         input CLOCK_50,
         input CLOCK2_50,
         input CLOCK3_50,
         input CLOCK4_50,

         //////////// SEG7 //////////
         output [ 6: 0 ] HEX0,
         output [ 6: 0 ] HEX1,
         output [ 6: 0 ] HEX2,
         output [ 6: 0 ] HEX3,
         output [ 6: 0 ] HEX4,
         output [ 6: 0 ] HEX5,

         //////////// KEY //////////
         input [ 3: 0 ] KEY,

         //////////// LED //////////
         output [ 9: 0 ] LEDR,

         //////////// SW //////////
         input [ 9: 0 ] SW,

         //////////// VGA //////////
         output [ 7: 0 ] VGA_B,
         output VGA_BLANK_N,
         output VGA_CLK,
         output [ 7: 0 ] VGA_G,
         output VGA_HS,
         output [ 7: 0 ] VGA_R,
         output VGA_SYNC_N,
         output VGA_VS,

         //////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_0,

         //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_1
       );

//=======================================================
//  REG/WIRE declarations
//=======================================================
//****USER INPUT/BOARD SPECIFIC VALUES****//
wire clk_50;								//Board clock at 50 MHz
wire p1_up, p1_down;						//Board buttons to control paddle
wire encoderA, encoderB;				//Motor encoder signals
wire [13:0] p1_hex, p2_hex;			//Hex displays for each player's score
wire pause, continue;					//Pause feature and button to let play continue after scoring
//****GAME VALUES****//
wire [3:0] p1_score, p2_score;		//Saves player scores
wire [7:0] p1_pos, p2_pos;				//Saves each paddle's y position
wire [8:0] ball_x, ball_y;				//Saves ball's position
wire did_collide;							//Asserted when ball bounces off of paddle or wall
//****ADC/DAC VALUES****/
wire audio_clk;							//Shared clock
wire adc_din, adc_cs, adc_dout;		//ADC interface components
wire adc_valid;							//Internal variables to operate ADC
wire dac_in, dac_sync;					//DAC interface components
//****VIDEO VALUES****//
wire disp_clk, disp_en;					//Display clock and enable
wire hsync, vsync;						//Video synchronization signals to paint to screen
wire [7:0] red, green, blue;			//Saves RGB value to be output to screen
	
//=======================================================
//  Structural coding
//=======================================================
//****CONNECT TO BOARD****/
assign clk_50 = CLOCK_50;																															//50 MHz clock
assign {pause, continue} = {SW[0], ~KEY[3]};																									//Pause switch and continue button
assign {p1_up, p1_down} = {~KEY[0], ~KEY[1]};																								//Player 1 paddle controls (buttons)
assign {encoderB, encoderA} = GPIO_0[7:6];																									//Player 2 paddle controls (motor encoder)
assign {HEX5[6:0], HEX4[6:0], HEX1[6:0], HEX0[6:0]} = {~p1_hex[13:0], ~p2_hex[13:0]};											//2-digit "scoreboards" for each player
assign {HEX2[6:0], HEX3[6:0]} = 14'h3fff;																										//Turn off the other digit displays
assign {GPIO_0[14:8], GPIO_0[17]} = {adc_din, audio_clk, 2'b00, dac_sync, dac_in, audio_clk, adc_cs};						//Connect audio components correctly
assign adc_dout = GPIO_0[15];																														//Retrieve ADC output data
assign {GPIO_1[31:19], GPIO_1[17], GPIO_1[15:3], GPIO_1[1]} = {vsync, hsync, disp_en, disp_clk, blue, green, red};	//Connect video components correctly
//****CONNECT MODULES CORRECTLY****
pll video_pll(						//Slow display clock to 9 MHz to get 60 fps refresh rate
	.refclk(clk_50),
	.rst(1'b0),
	.outclk_0(disp_clk),
	.locked(disp_en)
);

pll2 audio_pll(					//Slow ADC/DAC clock to 16 MHz to be compatible with ADC specs
	.refclk(clk_50),
	.rst(1'b0),
	.outclk_0(audio_clk)
);

video_sync_generator signals(	//Generate hsync and vsync signals
	.clk(disp_clk),
	.hsync(hsync),
	.vsync(vsync)
);

move_paddles mover(				//Moves the paddles
	.clk(clk_50),
	.p1_up(p1_up),
	.p1_down(p1_down),
	.encoderA(encoderA),
	.encoderB(encoderB),
	.pause(pause),
	.p1_pos(p1_pos),
	.p2_pos(p2_pos)
);

game_play mechanics(				//Dictates ball movement and keeps score
	.clk(clk_50),
	.p1_pos(p1_pos),
	.p2_pos(p2_pos),
	.pause(pause),
	.continue(continue),
	.p1_score(p1_score),
	.p2_score(p2_score),
	.ball_x(ball_x),
	.ball_y(ball_y),
	.did_collide(did_collide)
);

score_control update(			//Updates the score display to reflect the current scores
	.clk(clk_50),
	.p1_score(p1_score),
	.p2_score(p2_score),
	.p1_hex(p1_hex),
	.p2_hex(p2_hex)
);

sounds manager(					//Uses submodules to read data from ADC and collision data to properly output to DAC
	.clk_50(clk_50),
	.audio_clk(audio_clk),
	.adc_out(adc_dout),
	.did_collide(did_collide),
	.p1_score(p1_score),
	.p2_score(p2_score),
	.adc_in(adc_din),
	.cs(adc_cs),
	.dac_in(dac_in),
	.sync(dac_sync)
);

paint update_screen(				//Displays everything to the screen
	.clk(disp_clk),
	.hsync(hsync),
	.vsync(vsync),
	.p1_pos(p1_pos),
	.p2_pos(p2_pos),
	.ball_x(ball_x),
	.ball_y(ball_y),
	.red(red),
	.green(green),
	.blue(blue)
);
endmodule
